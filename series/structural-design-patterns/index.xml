<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Structural Design Patterns on</title><link>https://gosang.github.io/series/structural-design-patterns/</link><description>Recent content in Structural Design Patterns on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Aug 2021 12:55:19 +0000</lastBuildDate><atom:link href="https://gosang.github.io/series/structural-design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Facade Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/facade-pattern/</link><pubDate>Fri, 20 Aug 2021 12:55:19 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/facade-pattern/</guid><description>In the world of software development, dealing with complex systems is a common challenge. As systems grow in size and functionality, managing and using their various components can become overwhelming. This is where the Facade Pattern comes to the rescue. In this blog post, we will explore what the Facade Pattern is, its rationale, how it can be used, and its relevance in the context of microservices and modular monolithic applications.</description></item><item><title>Adapter Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/adapter-pattern/</link><pubDate>Thu, 22 Jul 2021 08:37:58 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/adapter-pattern/</guid><description>In the world of software development, you often encounter scenarios where you need to integrate new components or systems with existing ones. These components may not always speak the same &amp;ldquo;language,&amp;rdquo; and bridging this gap can be a challenging task. That&amp;rsquo;s where the Adapter Pattern comes to the rescue. In this blog, we will dive deep into the Adapter Pattern, understand its purpose, see how it resolves integration problems, and explore its usage in the context of microservices and modular monolithic applications using C# .</description></item><item><title>Proxy Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/proxy-pattern/</link><pubDate>Tue, 15 Jun 2021 12:26:08 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/proxy-pattern/</guid><description>When building complex software systems, especially in the context of microservices or modular monolithic applications, managing resources efficiently and controlling access to them becomes crucial. The Proxy Pattern is a powerful design pattern that helps solve these challenges by providing a surrogate or placeholder for another object to control its access. In this blog, we will dive deep into the Proxy Pattern, explore its rationale, use cases, advantages, disadvantages, and best practices.</description></item><item><title>Composite Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/composite-pattern/</link><pubDate>Fri, 16 Apr 2021 12:56:42 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/composite-pattern/</guid><description>The Composite Pattern is a structural design pattern that allows you to compose objects into tree structures to represent part-whole hierarchies. This pattern lets clients treat individual objects and compositions of objects uniformly. In simpler terms, it enables you to work with both individual objects and groups of objects in a unified manner.
Rationale behind the Composite Pattern The primary goal of the Composite Pattern is to treat individual objects and compositions of objects uniformly.</description></item><item><title>Interpreter Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/interpreter-pattern/</link><pubDate>Tue, 23 Feb 2021 13:00:16 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/interpreter-pattern/</guid><description>In the realm of design patterns, the Interpreter pattern stands out as a powerful tool for solving specific types of problems. This blog post will delve into the intricacies of the Interpreter pattern, exploring what it is, its rationale, applications in the context of microservices or modular monolithic architectures, and providing practical examples using C# .NET Core.
What is the Interpreter Pattern? The Interpreter pattern falls under the behavioral design patterns category.</description></item><item><title>Flyweight Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/flyweight-pattern/</link><pubDate>Thu, 05 Nov 2020 12:28:06 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/flyweight-pattern/</guid><description>The Flyweight design pattern is a structural pattern that falls under the category of design patterns in software engineering. It is used to optimize memory usage or computational resources by sharing as much as possible with related objects. The Flyweight pattern is particularly valuable when you need to create a large number of similar objects and you want to conserve resources.
In this blog, we will delve into the Flyweight design pattern, its rationale, how it resolves common problems, and how to implement it using C# .</description></item><item><title>Decorator Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/decorator-pattern/</link><pubDate>Fri, 28 Aug 2020 12:27:13 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/decorator-pattern/</guid><description>In software development, design patterns play a pivotal role in structuring and organizing code to make it more maintainable and extensible. One such design pattern that proves to be invaluable in enhancing the functionality of objects without altering their structure is the Decorator Pattern. In this blog, we will delve into the Decorator Pattern, its rationale, implementation in C# .NET Core, and how it can be beneficial for microservices and modular monolithic applications.</description></item><item><title>Bridge Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/bridge-pattern/</link><pubDate>Fri, 17 Jul 2020 13:13:29 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/bridge-pattern/</guid><description>In the realm of software design patterns, the Bridge pattern stands out as a powerful tool for enhancing flexibility and maintainability. This pattern belongs to the structural design patterns, emphasizing the decoupling of abstraction from implementation. In this blog post, we&amp;rsquo;ll delve into the intricacies of the Bridge pattern, its rationale, usage in microservices, and practical implementations in a C# .NET Core e-commerce system.
Bridge Pattern Overview The Bridge pattern is a structural pattern that separates abstraction from its implementation so that both can evolve independently without affecting each other.</description></item></channel></rss>