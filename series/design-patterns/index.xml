<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns on</title><link>https://gosang.github.io/series/design-patterns/</link><description>Recent content in Design Patterns on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 03 Aug 2023 08:43:48 +0000</lastBuildDate><atom:link href="https://gosang.github.io/series/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Difference Between Imemorycache and Redis</title><link>https://gosang.github.io/posts/design-patterns/caching/difference-between-imemorycache-and-redis/</link><pubDate>Thu, 03 Aug 2023 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/caching/difference-between-imemorycache-and-redis/</guid><description>.NET Core IMemoryCache Overview: In .NET Core, the IMemoryCache interface is a built-in caching mechanism that provides an in-memory store for frequently accessed data. It is part of the Microsoft.Extensions.Caching.Memory namespace and is a simple and lightweight caching solution native to the .NET Core framework.
Key Features: 1. Native Integration:
Seamlessly integrated into the .NET Core framework. No need for additional dependencies or external services. 2. In-Memory Storage:
Utilizes the application&amp;rsquo;s memory to store cached data.</description></item><item><title>Caching Pattern</title><link>https://gosang.github.io/posts/design-patterns/caching/caching-pattern/</link><pubDate>Fri, 28 Jul 2023 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/caching/caching-pattern/</guid><description>Caching is a crucial aspect of modern software development, especially in the context of microservices or modular monolithic applications. It helps improve performance, reduce latency, and enhance the overall user experience. In this blog post, we will delve into five caching patterns: Cache Aside, Write Through, Read Through, Write Back, and Write Around, exploring their characteristics, use cases, and code snippets using .NET.
1. Cache Aside Overview: Cache Aside, also known as Lazy Loading, is a popular caching pattern where the application code is responsible for managing the cache.</description></item><item><title>Applying the Outbox Design Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/applying-outbox-pattern/</link><pubDate>Mon, 10 Jul 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/applying-outbox-pattern/</guid><description>In the realm of microservices architectures, managing distributed transactions and ensuring data consistency across services can be challenging. The Outbox Design Pattern is a powerful solution to address these challenges, by facilitating the decoupling of business logic from the intricacies of distributed transactions. It aims to ensure atomicity and consistency of operations across multiple microservices or components.
In this blog, we will delve into applying the Outbox Design Pattern in a simple problem.</description></item><item><title>General Responsibility Assignment Software Patterns (GRASP)</title><link>https://gosang.github.io/posts/design-patterns/object-oriented/grasp/</link><pubDate>Thu, 22 Jun 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/object-oriented/grasp/</guid><description>When it comes to designing software systems, achieving a clear and maintainable architecture is paramount. General Responsibility Assignment Software Patterns (GRASP) is a set of principles that aids in designing object-oriented systems with a focus on responsibility assignment. In this blog post, we will delve into the core concepts of GRASP, its rationale, and how it can be effectively applied in the context of an e-commerce system using .NET Core, MediatR, AutoMapper, EF Core InMemory database, and React.</description></item><item><title>Outbox Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/outbox-pattern/</link><pubDate>Sun, 30 Apr 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/outbox-pattern/</guid><description>In the realm of microservices and modular monolithic architectures, managing distributed transactions and ensuring data consistency across services can be challenging. The Outbox Design Pattern is a powerful solution to address these challenges. In this blog, we will delve into the intricacies of the Outbox Design Pattern, its rationale, implementation using Entity Framework Core 6 in C# .NET Core, and discuss its advantages, disadvantages, use cases, and best practices.
What is the Outbox Design Pattern?</description></item><item><title>Strangler Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/strangler-pattern/</link><pubDate>Sun, 09 Apr 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/strangler-pattern/</guid><description>In the realm of software development, the Strangler Pattern emerges as a strategic approach to modernizing applications. It offers a gradual migration from monolithic architectures to microservices, allowing developers to replace components without disrupting the entire system. This blog post explores the Strangler Pattern, its application in an e-commerce system using .NET, and best practices for a smooth transition.
What is the Strangler Pattern? The Strangler Pattern, coined by Martin Fowler, is a migration strategy that involves incrementally replacing components of an existing system.</description></item><item><title>Event Sourcing Design Pattern</title><link>https://gosang.github.io/posts/design-patterns/event-sourcing-pattern/</link><pubDate>Sat, 18 Mar 2023 08:49:40 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/event-sourcing-pattern/</guid><description>Event Sourcing is a powerful design pattern that has gained significant traction in the software development world. This pattern offers a novel approach to managing data changes, particularly in the context of microservices and modular monolithic architectures. In this guide, we will provide a detailed exploration of Event Sourcing, covering what it is, why it&amp;rsquo;s used, practical examples using C# .NET Core, the advantages and disadvantages, when to use it, and best practices.</description></item><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://gosang.github.io/posts/design-patterns/command-query-responsibility-segregation/</link><pubDate>Wed, 01 Mar 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/command-query-responsibility-segregation/</guid><description>In the ever-evolving world of software architecture, Command Query Responsibility Segregation (CQRS) has emerged as a powerful design pattern. CQRS is all about separating the responsibilities of executing commands (actions that change the state of an application) and handling queries (read-only operations).
In this article, we&amp;rsquo;ll delve deep into CQRS, exploring what it is, the rationale behind it, the problems it solves, practical usage with C# .NET Core Web API and repositories, and its advantages and disadvantages.</description></item><item><title>Repository Unit of Work</title><link>https://gosang.github.io/posts/design-patterns/repository-unit-of-work/</link><pubDate>Sat, 12 Feb 2022 08:56:22 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/repository-unit-of-work/</guid><description>In the ever-evolving landscape of software architecture and data management, certain design patterns stand out as foundational concepts that can greatly improve the organization and maintainability of your applications. Among these, the Repository Pattern and the Unit of Work Pattern are two of the most vital. In this comprehensive guide, we&amp;rsquo;ll explore these patterns in depth, understand their significance, and learn how to wield them effectively in a C# .NET Core Web API, harnessing the capabilities of Entity Framework Core 6.</description></item><item><title>Repository Pattern</title><link>https://gosang.github.io/posts/design-patterns/repository-pattern/</link><pubDate>Sat, 29 Jan 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/repository-pattern/</guid><description>In the realm of software development, maintaining a clean, organized, and efficient codebase is paramount. One of the key design patterns that facilitates this is the Repository Pattern. In this comprehensive guide, we&amp;rsquo;ll embark on a journey to understand the Repository Pattern from the ground up, exploring its purpose, the problems it elegantly resolves, and how to employ it in a C# .NET Core Web API powered by Entity Framework Core 6.</description></item><item><title>Null Object Pattern</title><link>https://gosang.github.io/posts/design-patterns/null-object-pattern/</link><pubDate>Tue, 03 Aug 2021 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/null-object-pattern/</guid><description>In the world of software development, handling null values can be a persistent challenge. The Null Object pattern is a design pattern that addresses this challenge by providing a systematic way to represent and handle null objects. This blog post aims to explore the Null Object pattern in-depth, covering its definition, rationale, usage, implementation in C# .NET Core with CacheStorage, advantages, disadvantages, use cases, and best practices.
Understanding the Null Object Pattern What is the Null Object Pattern?</description></item></channel></rss>