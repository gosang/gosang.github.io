<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Microservices on</title><link>https://gosang.github.io/tags/microservices/</link><description>Recent content in Microservices on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Nov 2023 13:58:28 +0000</lastBuildDate><atom:link href="https://gosang.github.io/tags/microservices/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC: Revolutionizing Communication in Modern Microservices with .NET Core</title><link>https://gosang.github.io/posts/design-principles/microservices/grpc/</link><pubDate>Wed, 01 Nov 2023 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/microservices/grpc/</guid><description>Introduction In the dynamic landscape of microservices architecture, efficient communication between services is paramount. Enter gRPC, which stands for gRPC Remote Procedure Call. It&amp;rsquo;s a high-performance, open-source RPC (Remote Procedure Call) framework developed by Google. In this blog post, we&amp;rsquo;ll look into the intricacies of gRPC, explore its application in the context of a .NET 6 e-commerce system, and discuss best practices and use cases.
Understanding gRPC What is gRPC? gRPC is a framework that facilitates communication between distributed systems by enabling clients to make calls to methods on a server application as if it were a local object.</description></item><item><title>Implementing Event Bus With RabbitMQ in .NET Core</title><link>https://gosang.github.io/posts/design-principles/messaging/implementing-event-bus-with-rabbitmq-in-dotnet-core/</link><pubDate>Wed, 30 Aug 2023 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/messaging/implementing-event-bus-with-rabbitmq-in-dotnet-core/</guid><description>As a Software Engineer, you understand the importance of efficient communication between components in a distributed system. In this blog post, we&amp;rsquo;ll explore the implementation of an event bus with RabbitMQ in .NET Core, focusing on an e-commerce system built using .NET Core services and APIs. We&amp;rsquo;ll leverage MediatR for CQRS, AutoMapper for object mapping, EF Core InMemory database for simplicity, and xUnit for unit tests. Let&amp;rsquo;s dive into the rationale, implementation steps, advantages, and best practices.</description></item><item><title>Applying the Outbox Design Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/applying-outbox-pattern/</link><pubDate>Mon, 10 Jul 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/applying-outbox-pattern/</guid><description>In the realm of microservices architectures, managing distributed transactions and ensuring data consistency across services can be challenging. The Outbox Design Pattern is a powerful solution to address these challenges, by facilitating the decoupling of business logic from the intricacies of distributed transactions. It aims to ensure atomicity and consistency of operations across multiple microservices or components.
In this blog, we will look into applying the Outbox Design Pattern in a simple problem.</description></item><item><title>Outbox Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/outbox-pattern/</link><pubDate>Sun, 30 Apr 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/outbox-pattern/</guid><description>In the realm of microservices and modular monolithic architectures, managing distributed transactions and ensuring data consistency across services can be challenging. The Outbox Design Pattern is a powerful solution to address these challenges. In this blog, we will look into the intricacies of the Outbox Design Pattern, its rationale, implementation using Entity Framework Core 6 in C# .NET Core, and discuss its advantages, disadvantages, use cases, and best practices.
What is the Outbox Design Pattern?</description></item><item><title>Strangler Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/strangler-pattern/</link><pubDate>Sun, 09 Apr 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/strangler-pattern/</guid><description>In the realm of software development, the Strangler Pattern emerges as a strategic approach to modernizing applications. It offers a gradual migration from monolithic architectures to microservices, allowing developers to replace components without disrupting the entire system. This blog post explores the Strangler Pattern, its application in an e-commerce system using .NET, and best practices for a smooth transition.
What is the Strangler Pattern? The Strangler Pattern, coined by Martin Fowler, is a migration strategy that involves incrementally replacing components of an existing system.</description></item><item><title>Event Sourcing Design Pattern</title><link>https://gosang.github.io/posts/design-patterns/event-sourcing-pattern/</link><pubDate>Sat, 18 Mar 2023 08:49:40 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/event-sourcing-pattern/</guid><description>Event Sourcing is a powerful design pattern that has gained significant traction in the software development world. This pattern offers a novel approach to managing data changes, particularly in the context of microservices and modular monolithic architectures. In this guide, we will provide a detailed exploration of Event Sourcing, covering what it is, why it&amp;rsquo;s used, practical examples using C# .NET Core, the advantages and disadvantages, when to use it, and best practices.</description></item><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://gosang.github.io/posts/design-patterns/command-query-responsibility-segregation/</link><pubDate>Wed, 01 Mar 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/command-query-responsibility-segregation/</guid><description>In the ever-evolving world of software architecture, Command Query Responsibility Segregation (CQRS) has emerged as a powerful design pattern. CQRS is all about separating the responsibilities of executing commands (actions that change the state of an application) and handling queries (read-only operations).
In this article, we&amp;rsquo;ll look deep into CQRS, exploring what it is, the rationale behind it, the problems it solves, practical usage with C# .NET Core Web API and repositories, and its advantages and disadvantages.</description></item><item><title>Using RabbitMQ with ASP.NET Core</title><link>https://gosang.github.io/posts/design-principles/messaging/rabbitmq-with-dotnet-core/</link><pubDate>Wed, 29 Jun 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/messaging/rabbitmq-with-dotnet-core/</guid><description>In the ever-evolving landscape of modern software development, efficient communication between components is crucial. As applications grow in complexity and adopt microservices architecture, a reliable message broker is essential. RabbitMQ, a powerful open-source message broker, has become a cornerstone technology for achieving scalable and robust communication between different parts of an application. In this blog, we will dive deep into RabbitMQ, explain its rationale, explore how it resolves common problems, and demonstrate its usage with ASP.</description></item><item><title>Understanding Idempotency in Microservices with .NET Core</title><link>https://gosang.github.io/posts/design-principles/microservices/idempotency/</link><pubDate>Mon, 25 Apr 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/microservices/idempotency/</guid><description>Introduction In distributed systems and microservices architecture, ensuring the reliability and consistency of operations becomes a critical challenge. One key concept that plays a pivotal role in addressing this challenge is Idempotency. In this blog post, we&amp;rsquo;ll look into the meaning of Idempotency, explore its rationale, understand its applications in the context of microservices (using .NET Core), and discuss the advantages, disadvantages, and best practices associated with it.
What is Idempotency?</description></item><item><title>Apache Kafka With .NET Core</title><link>https://gosang.github.io/posts/design-principles/messaging/apache-kafka-with-dotnet-core/</link><pubDate>Sat, 09 Apr 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/messaging/apache-kafka-with-dotnet-core/</guid><description>Introduction Apache Kafka has emerged as a game-changer in the realm of distributed systems, offering a robust and scalable solution for building event-driven architectures. In this technical blog, we will look into the intricacies of Apache Kafka, exploring its core concepts, implementation in a .NET Core e-commerce system, and discussing the advantages, disadvantages, issues, and best practices associated with its use.
Understanding Apache Kafka What is Apache Kafka? Apache Kafka is a distributed streaming platform that excels at handling real-time data feeds and creating scalable, fault-tolerant, and high-throughput messaging systems.</description></item><item><title>Saga Patterns</title><link>https://gosang.github.io/posts/design-patterns/microservices/saga-patterns/</link><pubDate>Sat, 30 Oct 2021 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/saga-patterns/</guid><description>Microservices architecture has revolutionized the way we design and deploy applications, but it introduces challenges in managing transactions across distributed services. Saga Patterns emerge as a powerful solution to address these challenges and ensure data consistency in a microservices environment. In this blog post, we will explore the Saga Pattern, its variants (Choreographer and Orchestrator Patterns), anti-patterns, and provide practical insights using .NET Core for an e-commerce system.
What is Saga Pattern?</description></item><item><title>Publish–subscribe Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/publishsubscribe-pattern/</link><pubDate>Thu, 09 Sep 2021 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/publishsubscribe-pattern/</guid><description>The Publish–Subscribe pattern, a stalwart in the realm of messaging patterns, orchestrates communication between components in a decoupled manner. Here, publishers categorize messages into topics and broadcast them without knowing the identity of subscribers. Subscribers express interest in specific topics, receiving messages related to those topics. Let&amp;rsquo;s look into the intricacies of this pattern, exploring its rationale, problem-solving capabilities, and its implementation in the context of a .NET Core e-commerce system.</description></item><item><title>Microservices Design Architecture</title><link>https://gosang.github.io/posts/design-architectures/microservices/</link><pubDate>Tue, 30 Jun 2020 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/microservices/</guid><description>In the ever-evolving landscape of software development, Microservices Design Architecture has emerged as a game-changer. This architectural paradigm brings flexibility, scalability, and maintainability to the forefront. In this blog, we&amp;rsquo;ll take a deep dive into what microservices are, their key concepts, design architecture, and when to leverage this approach for building robust systems.
What are Microservices? Microservices is an architectural style where a software application is composed of small, independent services that communicate with each other through well-defined APIs.</description></item></channel></rss>