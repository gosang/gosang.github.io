<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns on</title><link>https://gosang.github.io/tags/design-patterns/</link><description>Recent content in Design Patterns on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 10 Oct 2022 08:28:08 +0000</lastBuildDate><atom:link href="https://gosang.github.io/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Mediator Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/mediator-pattern/</link><pubDate>Mon, 10 Oct 2022 08:28:08 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/mediator-pattern/</guid><description>In the realm of software design, the Mediator Pattern shines as a potent tool for simplifying complex systems, promoting loose coupling, and improving maintainability. Whether you&amp;rsquo;re developing microservices or working on modular monolithic applications, the Mediator Pattern can be a game-changer.
In this blog, we&amp;rsquo;ll dive deep into the Mediator Pattern, uncovering what it is, the rationale behind it, the problems it addresses, and how to implement it using .NET Core.</description></item><item><title>Chain of Responsibility Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/chain-of-responsibility-pattern/</link><pubDate>Tue, 01 Mar 2022 12:22:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/chain-of-responsibility-pattern/</guid><description>The Chain of Responsibility Pattern is a behavioral design pattern that allows you to pass requests along a chain of handlers. Each handler can choose to process the request or pass it to the next handler in the chain. This pattern promotes loose coupling between the sender and receiver of a request, making it a powerful tool in building extensible and maintainable software systems. In this blog, we will explore what the Chain of Responsibility Pattern is, its rationale, how it can be used in C# .</description></item><item><title>Factory Pattern</title><link>https://gosang.github.io/posts/design-patterns/creational/factory-pattern/</link><pubDate>Sun, 05 Dec 2021 13:19:18 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/creational/factory-pattern/</guid><description>Design patterns play a crucial role in creating modular, scalable, and maintainable software. Among them, Factory Patterns are widely used to encapsulate object creation, providing a flexible way to instantiate objects without specifying their exact classes. In this blog, we&amp;rsquo;ll explore three types of Factory Patterns: Concrete, Static, and Abstract, discussing their rationale, usage in an e-commerce system with C# .NET Core examples, advantages, disadvantages, and best practices.
Factory Patterns Overview What is a Factory Pattern?</description></item><item><title>Strategy Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/strategy-pattern/</link><pubDate>Thu, 25 Nov 2021 11:26:09 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/strategy-pattern/</guid><description>When designing software systems, it&amp;rsquo;s essential to create flexible and maintainable code. One way to achieve this is by using design patterns, which are well-established solutions to common software design problems. The Strategy Pattern is one such pattern that offers a structured approach to defining a family of algorithms and making them interchangeable.
In this blog post, we&amp;rsquo;ll explore the Strategy Pattern in detail, its rationale, how it solves problems, and its application in various contexts, including microservices and modular monolithic architectures, using C# .</description></item><item><title>Observer Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/observer-pattern/</link><pubDate>Wed, 13 Oct 2021 12:40:53 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/observer-pattern/</guid><description>In software development, designing systems that are flexible, scalable, and maintainable is paramount. One of the key challenges is establishing a communication mechanism between components without tight coupling. The Observer pattern provides an elegant solution to this problem. In this blog, we&amp;rsquo;ll delve into the intricacies of the Observer pattern, explore its applications in an e-commerce system using C# .NET Core, and discuss best practices.
Understanding the Observer Pattern The Observer pattern is a behavioral design pattern where an object, known as the subject, maintains a list of its dependents, called observers, that are notified of state changes.</description></item><item><title>Facade Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/facade-pattern/</link><pubDate>Fri, 20 Aug 2021 12:55:19 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/facade-pattern/</guid><description>In the world of software development, dealing with complex systems is a common challenge. As systems grow in size and functionality, managing and using their various components can become overwhelming. This is where the Facade Pattern comes to the rescue. In this blog post, we will explore what the Facade Pattern is, its rationale, how it can be used, and its relevance in the context of microservices and modular monolithic applications.</description></item><item><title>Adapter Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/adapter-pattern/</link><pubDate>Thu, 22 Jul 2021 08:37:58 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/adapter-pattern/</guid><description>In the world of software development, you often encounter scenarios where you need to integrate new components or systems with existing ones. These components may not always speak the same &amp;ldquo;language,&amp;rdquo; and bridging this gap can be a challenging task. That&amp;rsquo;s where the Adapter Pattern comes to the rescue. In this blog, we will dive deep into the Adapter Pattern, understand its purpose, see how it resolves integration problems, and explore its usage in the context of microservices and modular monolithic applications using C# .</description></item><item><title>Proxy Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/proxy-pattern/</link><pubDate>Tue, 15 Jun 2021 12:26:08 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/proxy-pattern/</guid><description>When building complex software systems, especially in the context of microservices or modular monolithic applications, managing resources efficiently and controlling access to them becomes crucial. The Proxy Pattern is a powerful design pattern that helps solve these challenges by providing a surrogate or placeholder for another object to control its access. In this blog, we will dive deep into the Proxy Pattern, explore its rationale, use cases, advantages, disadvantages, and best practices.</description></item><item><title>Composite Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/composite-pattern/</link><pubDate>Fri, 16 Apr 2021 12:56:42 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/composite-pattern/</guid><description>The Composite Pattern is a structural design pattern that allows you to compose objects into tree structures to represent part-whole hierarchies. This pattern lets clients treat individual objects and compositions of objects uniformly. In simpler terms, it enables you to work with both individual objects and groups of objects in a unified manner.
Rationale behind the Composite Pattern The primary goal of the Composite Pattern is to treat individual objects and compositions of objects uniformly.</description></item><item><title>Visitor Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/visitor-pattern/</link><pubDate>Sat, 13 Mar 2021 12:23:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/visitor-pattern/</guid><description>The Visitor Pattern is a design pattern that provides a way to separate the algorithm from the object structure it operates on. It is a powerful and flexible pattern that is often used to add new operations to a set of classes without modifying their source code. In this blog, we will dive deep into the Visitor Pattern, explore its rationale, benefits, and drawbacks, and provide real-world examples in the context of a .</description></item><item><title>Interpreter Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/interpreter-pattern/</link><pubDate>Tue, 23 Feb 2021 13:00:16 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/interpreter-pattern/</guid><description>In the realm of design patterns, the Interpreter pattern stands out as a powerful tool for solving specific types of problems. This blog post will delve into the intricacies of the Interpreter pattern, exploring what it is, its rationale, applications in the context of microservices or modular monolithic architectures, and providing practical examples using C# .NET Core.
What is the Interpreter Pattern? The Interpreter pattern falls under the behavioral design patterns category.</description></item><item><title>Flyweight Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/flyweight-pattern/</link><pubDate>Thu, 05 Nov 2020 12:28:06 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/flyweight-pattern/</guid><description>The Flyweight design pattern is a structural pattern that falls under the category of design patterns in software engineering. It is used to optimize memory usage or computational resources by sharing as much as possible with related objects. The Flyweight pattern is particularly valuable when you need to create a large number of similar objects and you want to conserve resources.
In this blog, we will delve into the Flyweight design pattern, its rationale, how it resolves common problems, and how to implement it using C# .</description></item><item><title>State Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/state-pattern/</link><pubDate>Thu, 08 Oct 2020 12:28:51 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/state-pattern/</guid><description>State Pattern
Introduction In the ever-evolving landscape of software design, patterns play a crucial role in enhancing maintainability, scalability, and flexibility of code. One such design pattern that proves invaluable in managing state-dependent behavior is the State Pattern. In this blog post, we&amp;rsquo;ll delve into the State Pattern, exploring its rationale, application in real-world scenarios, and its advantages and disadvantages.
What is the State Pattern? The State Pattern is a behavioral design pattern that allows an object to alter its behavior when its internal state changes.</description></item><item><title>Prototype Pattern</title><link>https://gosang.github.io/posts/design-patterns/creational/prototype-pattern/</link><pubDate>Fri, 04 Sep 2020 13:09:32 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/creational/prototype-pattern/</guid><description>The Prototype pattern is a creational design pattern that focuses on creating objects by copying an existing object, known as the prototype. This pattern allows you to create new objects by duplicating an existing one, providing a convenient way to produce new instances without specifying their exact types. In this blog post, we&amp;rsquo;ll explore the Prototype pattern, its rationale, implementation in C# .NET Core, and its relevance in the context of microservices and modular monolithic architectures.</description></item><item><title>Decorator Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/decorator-pattern/</link><pubDate>Fri, 28 Aug 2020 12:27:13 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/decorator-pattern/</guid><description>In software development, design patterns play a pivotal role in structuring and organizing code to make it more maintainable and extensible. One such design pattern that proves to be invaluable in enhancing the functionality of objects without altering their structure is the Decorator Pattern. In this blog, we will delve into the Decorator Pattern, its rationale, implementation in C# .NET Core, and how it can be beneficial for microservices and modular monolithic applications.</description></item><item><title>Bridge Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/bridge-pattern/</link><pubDate>Fri, 17 Jul 2020 13:13:29 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/bridge-pattern/</guid><description>In the realm of software design patterns, the Bridge pattern stands out as a powerful tool for enhancing flexibility and maintainability. This pattern belongs to the structural design patterns, emphasizing the decoupling of abstraction from implementation. In this blog post, we&amp;rsquo;ll delve into the intricacies of the Bridge pattern, its rationale, usage in microservices, and practical implementations in a C# .NET Core e-commerce system.
Bridge Pattern Overview The Bridge pattern is a structural pattern that separates abstraction from its implementation so that both can evolve independently without affecting each other.</description></item><item><title>Singleton Pattern</title><link>https://gosang.github.io/posts/design-patterns/creational/singleton-pattern/</link><pubDate>Tue, 16 Jun 2020 12:23:54 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/creational/singleton-pattern/</guid><description>Introduction Design patterns play a crucial role in software development, providing proven solutions to recurring problems. One such pattern is the Singleton pattern, a creational design pattern that ensures a class has only one instance and provides a global point of access to it.
What is the Singleton Pattern? The Singleton pattern restricts the instantiation of a class to a single instance and provides a global point of access to that instance.</description></item><item><title>Template Method Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/template-method-pattern/</link><pubDate>Sat, 23 May 2020 12:24:18 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/template-method-pattern/</guid><description>The Template Method Pattern is a fundamental design pattern in software development that provides a framework for defining the structure of an algorithm while allowing specific steps of the algorithm to be implemented by derived classes. In this blog, we will explore the Template Method Pattern in detail, including its rationale, how it&amp;rsquo;s used in C# .NET Core, and its relevance in both microservices and modular monolithic applications. We&amp;rsquo;ll also delve into its advantages and disadvantages, use cases, best practices, and recommendations.</description></item></channel></rss>