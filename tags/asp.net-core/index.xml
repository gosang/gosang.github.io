<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ASP.NET Core on</title><link>https://gosang.github.io/tags/asp.net-core/</link><description>Recent content in ASP.NET Core on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 08 Jun 2024 12:21:44 +0100</lastBuildDate><atom:link href="https://gosang.github.io/tags/asp.net-core/index.xml" rel="self" type="application/rss+xml"/><item><title>API Versioning in ASP.NET Core</title><link>https://gosang.github.io/posts/dotnet/api-versioning-in-asp-dotnet-core/</link><pubDate>Sat, 08 Jun 2024 12:21:44 +0100</pubDate><guid>https://gosang.github.io/posts/dotnet/api-versioning-in-asp-dotnet-core/</guid><description>API Versioning is a critical aspect of building and maintaining robust and scalable APIs. It allows developers to introduce new features and improvements while maintaining backward compatibility for existing clients. We will look into the rationale behind API versioning, the problems it resolves, and the implementations of various versioning strategies in ASP.NET Core.
Why API Versioning? Backward Compatibility: Ensures existing clients continue to function even when new features are added. Controlled Evolution: Allows incremental and controlled release of new functionalities.</description></item><item><title>Software Architecture Testing in .NET Core Using ArchUnit</title><link>https://gosang.github.io/posts/dotnet/software-architecture-testing-in-dotnet-using-archunit/</link><pubDate>Sat, 25 May 2024 12:18:59 +0100</pubDate><guid>https://gosang.github.io/posts/dotnet/software-architecture-testing-in-dotnet-using-archunit/</guid><description>In the dynamic world of software development, maintaining robust architecture is paramount. Architectural integrity ensures that our systems are scalable, maintainable, and reliable. However, verifying these architectural constraints can be challenging. This is where ArchUnit comes into playâ€”a powerful tool that can revolutionize how we test and enforce architecture in .NET Core projects.
What is ArchUnit? ArchUnit is an open-source library that provides a fluent API for writing architecture tests in Java and .</description></item><item><title>Rate Limiting in ASP.NET Core 8 Web API</title><link>https://gosang.github.io/posts/dotnet/rate-limiting-in-dot-core/</link><pubDate>Sat, 18 May 2024 12:49:29 +0100</pubDate><guid>https://gosang.github.io/posts/dotnet/rate-limiting-in-dot-core/</guid><description>Rate limiting is a critical aspect of modern web development, especially in scenarios where resources need to be protected from abuse or excessive usage. In the context of ASP.NET Core 8 Web API development, rate limiting provides a mechanism to control the number of requests made to the API within a specified time period. This blog post will look into the concept of rate limiting, its implementation in ASP.NET Core 8 Web API, its advantages and disadvantages, considerations for implementation, and best practices.</description></item><item><title>Load Stress Testing Dotnet Core Web Api With Apache Jmeter</title><link>https://gosang.github.io/posts/testing/load-stress-testing-dotnet-core-web-api-with-apache-jmeter/</link><pubDate>Mon, 13 May 2024 10:13:09 +0100</pubDate><guid>https://gosang.github.io/posts/testing/load-stress-testing-dotnet-core-web-api-with-apache-jmeter/</guid><description>Load and stress testing are essential aspects of ensuring the performance and reliability of web APIs. In this blog post, we&amp;rsquo;ll look into how to effectively conduct load and stress testing for ASP.NET Core 8 Web API using Apache JMeter. We&amp;rsquo;ll cover the rationale behind load and stress testing, their advantages and disadvantages, detailed methodologies, and best practices.
Understanding Load and Stress Testing What are Load and Stress Testing? Load testing involves simulating expected usage patterns on a software application to assess its behavior under normal and peak conditions.</description></item><item><title>Alert and Monitoring in .NET Core using Serilog and Elastic Kibana</title><link>https://gosang.github.io/posts/dotnet/alert-and-monitoring-in-dotnet-core-using-serilog-and-elastic-kibana/</link><pubDate>Sun, 05 May 2024 15:56:39 +0100</pubDate><guid>https://gosang.github.io/posts/dotnet/alert-and-monitoring-in-dotnet-core-using-serilog-and-elastic-kibana/</guid><description>In any software application, monitoring and alerting are crucial components for ensuring its reliability and availability. In this technical blog, we&amp;rsquo;ll explore how to implement alerting and monitoring in a .NET Core 8 Web API using Serilog for logging and Elastic Kibana for visualizing logs and setting up alerts.
Overview Serilog Serilog is a popular logging library for .NET applications. It provides a flexible configuration API and supports structured logging, enabling developers to log events and errors with various levels of severity.</description></item><item><title>Document Microservice With Swagger in .NET Core</title><link>https://gosang.github.io/posts/dotnet/document-microservice-with-swagger-in-dotnet-core/</link><pubDate>Sun, 28 Apr 2024 18:13:51 +0100</pubDate><guid>https://gosang.github.io/posts/dotnet/document-microservice-with-swagger-in-dotnet-core/</guid><description>In this blog, we will explore how to document a microservice API built with .NET Core using Swagger. Swagger is a powerful tool that enables developers to design, build, document, and consume RESTful APIs. We&amp;rsquo;ll look into creating a Swagger documentation for an online shopping domain microservice API, discussing implementation details, advantages, disadvantages, considerations, and best practices.
Understanding Swagger Swagger is an open-source framework that helps developers design and document APIs.</description></item><item><title>Understanding the Action, Func and Predicate Delegate Types in ASP.NET Core 8</title><link>https://gosang.github.io/posts/dotnet/understanding-action-func-and-predicate-delegate-types-in-asp.net-core-8/</link><pubDate>Sun, 17 Mar 2024 18:05:34 +0000</pubDate><guid>https://gosang.github.io/posts/dotnet/understanding-action-func-and-predicate-delegate-types-in-asp.net-core-8/</guid><description>Delegates are powerful constructs in C# that allow for defining and passing around references to methods, providing flexibility and extensibility in programming. Two commonly used delegate types in C# are Action and Func. In this blog post, we&amp;rsquo;ll look into what these delegate types are, their rationale, how they&amp;rsquo;re used, and provide examples to illustrate their utility.
What are Delegates? A delegate in C# is a type that represents references to methods with a particular parameter list and return type.</description></item><item><title>Securing ASP.NET Core Web API With OAuth 2.0 in Microsoft Entra ID</title><link>https://gosang.github.io/posts/dotnet/securing-asp-dotnet-core-web-api-with-oauth-2.0-in-microsoft-entra-id/</link><pubDate>Sun, 28 Jan 2024 14:22:05 +0000</pubDate><guid>https://gosang.github.io/posts/dotnet/securing-asp-dotnet-core-web-api-with-oauth-2.0-in-microsoft-entra-id/</guid><description>OAuth 2.0 is a widely adopted protocol for securing web applications and APIs. It provides a standardized way for third-party applications to obtain limited access to a user&amp;rsquo;s resources without exposing their credentials. In this blog post, we will explore the fundamentals of OAuth 2.0 and how to implement it to secure an ASP.NET Core Web API using Microsoft Entra ID.
Understanding OAuth 2.0 What is OAuth 2.0? OAuth 2.0 is an open standard authorization framework that enables secure, delegated access to resources.</description></item><item><title>Optimistic Concurrency With Etag in ASP.NET Core 8</title><link>https://gosang.github.io/posts/datastore/optimistic-concurrency-with-etag-in-asp-dotnet-core-8/</link><pubDate>Sat, 27 Jan 2024 13:14:30 +0000</pubDate><guid>https://gosang.github.io/posts/datastore/optimistic-concurrency-with-etag-in-asp-dotnet-core-8/</guid><description>Optimistic concurrency is a critical strategy for managing concurrent updates in modern web applications. The ETag header, or Entity Tag, serves as a powerful mechanism to implement optimistic concurrency. In this blog post, we&amp;rsquo;ll thoroughly explore what ETag is, its rationale, how it differs from pessimistic concurrency, and how to leverage it in a .NET Core 8 e-commerce system. Additionally, we&amp;rsquo;ll look into two approaches for optimistic concurrency: one using Database-Generated Tokens and another using Application-Managed Tokens.</description></item><item><title>Implementing Dapper With ASP.Core 6</title><link>https://gosang.github.io/posts/datastore/implementing-dapper-with-asp-dotnet-core-6/</link><pubDate>Sun, 21 Jan 2024 16:58:14 +0000</pubDate><guid>https://gosang.github.io/posts/datastore/implementing-dapper-with-asp-dotnet-core-6/</guid><description>Introduction In the realm of data access in ASP.NET Core 6, developers often face choices between various Object-Relational Mapping (ORM) tools. One such tool that has gained popularity is Dapper. In this blog post, we will look into what Dapper is, its rationale, and how it can be effectively implemented in an ASP.NET Core 6 E-Commerce system.
Understanding Dapper What is Dapper? Dapper is a simple, lightweight, and high-performance micro ORM developed by the creators of Stack Overflow.</description></item><item><title>Implementing Entity Framework Core 6 With ASP.NET Core 6</title><link>https://gosang.github.io/posts/datastore/implementing-entity-framework-core-6-with-asp.net-core-6/</link><pubDate>Sat, 20 Jan 2024 11:50:54 +0000</pubDate><guid>https://gosang.github.io/posts/datastore/implementing-entity-framework-core-6-with-asp.net-core-6/</guid><description>Introduction Entity Framework (EF) Core 6, coupled with ASP.NET Core 6, brings robust data access capabilities to the table, making it a preferred choice for building scalable and modular applications. In this blog post, we will explore the integration of EF Core 6 into an e-commerce system using .NET Core services and APIs.
What is EF Core 6 in ASP.NET Core 6? Entity Framework Core 6 is an Object-Relational Mapping (ORM) framework that simplifies database access in .</description></item><item><title>Implementing TTL (Time To Live) Feature in Mongodb Atlas With Dotnet Core</title><link>https://gosang.github.io/posts/datastore/implementing-ttl-feature-in-mongodb-atlas-with-dotnet-core/</link><pubDate>Sat, 13 Jan 2024 12:42:54 +0000</pubDate><guid>https://gosang.github.io/posts/datastore/implementing-ttl-feature-in-mongodb-atlas-with-dotnet-core/</guid><description>Introduction MongoDB, a popular NoSQL database, offers a unique feature called Time to Live (TTL), which allows documents to automatically expire after a specified period. In this blog post, we will explore the concept of TTL, its rationale, and how to implement it in an ASP.NET Core application using the MongoDB driver. We will use an e-commerce system as a case study to demonstrate the practical application of TTL in the context of microservices.</description></item><item><title>Implementing Mongodb Atlas With ASP.NET Core Using CQRS</title><link>https://gosang.github.io/posts/datastore/implementing-mongodb-atlas-with-dotnet-core-using-cqrs/</link><pubDate>Mon, 27 Jun 2022 18:01:02 +0000</pubDate><guid>https://gosang.github.io/posts/datastore/implementing-mongodb-atlas-with-dotnet-core-using-cqrs/</guid><description>Introduction In modern application development, choosing the right database solution is crucial for building scalable and efficient systems. MongoDB Atlas, combined with ASP.NET Core and the CQRS (Command Query Responsibility Segregation) pattern, offers a powerful and flexible solution for developing microservices-based applications. This technical blog aims to guide you through the process of implementing MongoDB Atlas with ASP.NET Core using the CQRS pattern, covering key aspects such as MediatR, Docker, and best practices.</description></item><item><title>Mongodb Atlas With .NET Core</title><link>https://gosang.github.io/posts/datastore/mongodb-atlas-with-dotnet-core/</link><pubDate>Sun, 27 Mar 2022 18:01:02 +0000</pubDate><guid>https://gosang.github.io/posts/datastore/mongodb-atlas-with-dotnet-core/</guid><description>Introduction In modern web development, choosing the right database solution is pivotal to building scalable and robust applications. MongoDB Atlas, coupled with ASP.NET Core, offers a compelling combination for developers seeking flexibility, scalability, and ease of development. This technical blog aims to provide a comprehensive understanding of MongoDB Atlas, its integration with ASP.NET Core, and the best practices for building microservices in the context of an e-commerce system.
MongoDB Atlas: Unveiling the Power What is MongoDB Atlas?</description></item><item><title>Exploring GraphQL With .NET Core</title><link>https://gosang.github.io/posts/dotnet/exploring-graphql-with-dotnet-core/</link><pubDate>Thu, 27 May 2021 18:01:02 +0000</pubDate><guid>https://gosang.github.io/posts/dotnet/exploring-graphql-with-dotnet-core/</guid><description>Understanding GraphQL GraphQL, developed by Facebook, is a query language for APIs that provides a more efficient, flexible, and powerful alternative to traditional REST APIs. Released in 2015, GraphQL allows clients to request exactly the data they need, addressing common issues associated with REST, such as over-fetching and under-fetching of data.
Why GraphQL? The primary goal of GraphQL is to optimize data retrieval. Traditional REST APIs often force clients to accept fixed responses, leading to over-fetching (receiving more data than necessary) or under-fetching (not receiving enough data, necessitating multiple requests).</description></item></channel></rss>