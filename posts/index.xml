<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on</title><link>https://gosang.github.io/posts/</link><description>Recent content in Posts on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 10 Jul 2023 19:18:44 +0000</lastBuildDate><atom:link href="https://gosang.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Applying the Outbox Design Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/applying-outbox-pattern/</link><pubDate>Mon, 10 Jul 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/applying-outbox-pattern/</guid><description>In the realm of microservices architectures, managing distributed transactions and ensuring data consistency across services can be challenging. The Outbox Design Pattern is a powerful solution to address these challenges, by facilitating the decoupling of business logic from the intricacies of distributed transactions. It aims to ensure atomicity and consistency of operations across multiple microservices or components.
In this blog, we will delve into applying the Outbox Design Pattern in a simple problem.</description></item><item><title>General Responsibility Assignment Software Patterns (GRASP)</title><link>https://gosang.github.io/posts/design-patterns/object-oriented/grasp/</link><pubDate>Thu, 22 Jun 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/object-oriented/grasp/</guid><description>When it comes to designing software systems, achieving a clear and maintainable architecture is paramount. General Responsibility Assignment Software Patterns (GRASP) is a set of principles that aids in designing object-oriented systems with a focus on responsibility assignment. In this blog post, we will delve into the core concepts of GRASP, its rationale, and how it can be effectively applied in the context of an e-commerce system using .NET Core, MediatR, AutoMapper, EF Core InMemory database, and React.</description></item><item><title>Large Language Models (LLMs)</title><link>https://gosang.github.io/posts/ai/llm/</link><pubDate>Fri, 09 Jun 2023 13:34:02 +0000</pubDate><guid>https://gosang.github.io/posts/ai/llm/</guid><description>Large Language Models (LLMs) have taken the world by storm, fundamentally changing the landscape of natural language processing and artificial intelligence. In this blog, we&amp;rsquo;ll delve into what LLMs are, their surge in popularity, how they function, their real-world applications, their advantages and limitations, as well as potential risks. We&amp;rsquo;ll also discuss when to use LLMs and explore future applications and research directions.
What is a Large Language Model? A Large Language Model (LLM) is an advanced type of artificial intelligence designed to understand and generate human language.</description></item><item><title>Domain Driven Design (DDD)</title><link>https://gosang.github.io/posts/design-architectures/domain-driven-design/</link><pubDate>Tue, 16 May 2023 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/domain-driven-design/</guid><description>Domain Driven Design (DDD) is a methodology that empowers developers to create software systems closely aligned with the complexities of real-world business domains. In this comprehensive guide, we will explore the fundamentals of DDD, its core concepts, and practical applications within an e-commerce system using C# .NET Core.
Understanding Domain Driven Design (DDD) At its essence, Domain Driven Design is an approach to software development that emphasizes collaboration between domain experts and developers.</description></item><item><title>Dependency Inversion Principle (DIP) and Dependency Injection (DI)</title><link>https://gosang.github.io/posts/design-principles/solid/dependency-inversion-principle/</link><pubDate>Thu, 04 May 2023 13:13:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/solid/dependency-inversion-principle/</guid><description>In the ever-evolving landscape of software design, the Dependency Inversion Principle (DIP) and Dependency Injection (DI) pattern shine as beacons of flexibility and maintainability. Both concepts, integral to the SOLID principles, play a pivotal role in creating loosely coupled and scalable systems. In this blog post, we&amp;rsquo;ll explore the Dependency Inversion Principle, delve into the Dependency Injection pattern, and discuss their application in the context of e-commerce using C# .NET Core.</description></item><item><title>Outbox Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/outbox-pattern/</link><pubDate>Sun, 30 Apr 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/outbox-pattern/</guid><description>In the realm of microservices and modular monolithic architectures, managing distributed transactions and ensuring data consistency across services can be challenging. The Outbox Design Pattern is a powerful solution to address these challenges. In this blog, we will delve into the intricacies of the Outbox Design Pattern, its rationale, implementation using Entity Framework Core 6 in C# .NET Core, and discuss its advantages, disadvantages, use cases, and best practices.
What is the Outbox Design Pattern?</description></item><item><title>Interface Segregation Principle (ISP)</title><link>https://gosang.github.io/posts/design-principles/solid/interface-segregation-principle/</link><pubDate>Sat, 22 Apr 2023 13:13:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/solid/interface-segregation-principle/</guid><description>In the quest for well-designed and modular software, the Interface Segregation Principle (ISP) emerges as a guiding principle for creating lean and focused interfaces. Coined by Robert C. Martin, ISP advocates that a class should not be forced to implement interfaces it does not use. In this blog post, we&amp;rsquo;ll explore the Interface Segregation Principle, understand its rationale, and discuss its application in the context of e-commerce using C# .NET Core.</description></item><item><title>Strangler Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/strangler-pattern/</link><pubDate>Sun, 09 Apr 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/strangler-pattern/</guid><description>In the realm of software development, the Strangler Pattern emerges as a strategic approach to modernizing applications. It offers a gradual migration from monolithic architectures to microservices, allowing developers to replace components without disrupting the entire system. This blog post explores the Strangler Pattern, its application in an e-commerce system using .NET, and best practices for a smooth transition.
What is the Strangler Pattern? The Strangler Pattern, coined by Martin Fowler, is a migration strategy that involves incrementally replacing components of an existing system.</description></item><item><title>Liskov Substitution Principle (LSP)</title><link>https://gosang.github.io/posts/design-principles/solid/liskov-substitution-principle/</link><pubDate>Sat, 01 Apr 2023 13:13:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/solid/liskov-substitution-principle/</guid><description>In the realm of object-oriented design, the Liskov Substitution Principle (LSP) stands as a guiding light, emphasizing the importance of substitutability among objects of a base class and its derived classes. Coined by Barbara Liskov, this principle ensures that derived classes can be used interchangeably with their base classes without affecting the correctness of the program. In this blog post, we will delve into the Liskov Substitution Principle, its rationale, practical examples in C# .</description></item><item><title>Event Sourcing Design Pattern</title><link>https://gosang.github.io/posts/design-patterns/event-sourcing-pattern/</link><pubDate>Sat, 18 Mar 2023 08:49:40 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/event-sourcing-pattern/</guid><description>Event Sourcing is a powerful design pattern that has gained significant traction in the software development world. This pattern offers a novel approach to managing data changes, particularly in the context of microservices and modular monolithic architectures. In this guide, we will provide a detailed exploration of Event Sourcing, covering what it is, why it&amp;rsquo;s used, practical examples using C# .NET Core, the advantages and disadvantages, when to use it, and best practices.</description></item><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://gosang.github.io/posts/design-patterns/command-query-responsibility-segregation/</link><pubDate>Wed, 01 Mar 2023 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/command-query-responsibility-segregation/</guid><description>In the ever-evolving world of software architecture, Command Query Responsibility Segregation (CQRS) has emerged as a powerful design pattern. CQRS is all about separating the responsibilities of executing commands (actions that change the state of an application) and handling queries (read-only operations).
In this article, we&amp;rsquo;ll delve deep into CQRS, exploring what it is, the rationale behind it, the problems it solves, practical usage with C# .NET Core Web API and repositories, and its advantages and disadvantages.</description></item><item><title>Open-Closed Principle (OCP)</title><link>https://gosang.github.io/posts/design-principles/solid/open-closed-principle/</link><pubDate>Sat, 11 Feb 2023 13:13:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/solid/open-closed-principle/</guid><description>In the world of software design, the Open-Closed Principle (OCP) stands tall as a beacon of extensibility and adaptability. Introduced by Bertrand Meyer, this principle advocates that a class should be open for extension but closed for modification. In this blog post, we will explore the Open-Closed Principle, understand its rationale, and see how it can be applied in the context of e-commerce, particularly in order management, shopping cart, and pricing modules.</description></item><item><title>Single Responsibility Principle (SRP)</title><link>https://gosang.github.io/posts/design-principles/solid/single-responsibility-principle/</link><pubDate>Thu, 02 Feb 2023 13:13:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/solid/single-responsibility-principle/</guid><description>In the realm of software design, the Single Responsibility Principle (SRP) is a fundamental guideline that advocates a class should have only one reason to change. Put simply, a class should have a single responsibility or, in other words, it should do one thing and do it well. This blog post will explore the SRP design principle, its rationale, practical examples in C# .NET Core, and its application.
What is SRP?</description></item><item><title>Securing Your Next.js 13 Application With Http Security Headers</title><link>https://gosang.github.io/posts/react/securing-your-nextjs-13-application-with-http-security-headers/</link><pubDate>Wed, 25 Jan 2023 18:16:44 +0100</pubDate><guid>https://gosang.github.io/posts/react/securing-your-nextjs-13-application-with-http-security-headers/</guid><description>In the ever-evolving landscape of web security, it&amp;rsquo;s essential to employ multiple layers of defense to protect your web applications and users. One of the fundamental aspects of securing your web application is implementing HTTP security headers. These headers are crucial in preventing various attacks such as cross-site scripting (XSS), clickjacking, code injection, and many others.
In this blog, we&amp;rsquo;ll explore what HTTP security headers are, why they are important, and how to set them up in a Next.</description></item><item><title>Feature Flags</title><link>https://gosang.github.io/posts/design-principles/feature-flags/</link><pubDate>Mon, 05 Dec 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/feature-flags/</guid><description>In the fast-paced world of software development, adapting to changing requirements and user needs is crucial. Feature Flags or Feature Toggles, emerge as a powerful technique to enable or disable features in a system without changing code. This blog explores what Feature Flags are, their rationale, advantages over conventional approaches, and practical implementation in a .NET 6 e-commerce system.
What are Feature Flags? Feature Flags are a development technique that allows developers to flag/toggle features in a system on or off at runtime without modifying code.</description></item><item><title>Mediator Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/mediator-pattern/</link><pubDate>Mon, 10 Oct 2022 08:28:08 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/mediator-pattern/</guid><description>In the realm of software design, the Mediator Pattern shines as a potent tool for simplifying complex systems, promoting loose coupling, and improving maintainability. Whether you&amp;rsquo;re developing microservices or working on modular monolithic applications, the Mediator Pattern can be a game-changer.
In this blog, we&amp;rsquo;ll dive deep into the Mediator Pattern, uncovering what it is, the rationale behind it, the problems it addresses, and how to implement it using .NET Core.</description></item><item><title>SOLID Design Principles</title><link>https://gosang.github.io/posts/design-principles/solid/solid/</link><pubDate>Thu, 01 Sep 2022 13:13:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/solid/solid/</guid><description>SOLID is a set of five design principles that aim to create robust, scalable, and maintainable software. These principles were introduced by Robert C. Martin and have become a cornerstone for object-oriented design. In this blog post, we&amp;rsquo;ll delve into each SOLID principle, discuss their rationale, provide practical examples in C# .NET Core, and explore how they can be applied in both monolithic and microservices architectures.
What is SOLID? SOLID is an acronym that represents five design principles:</description></item><item><title>DRY Design Principle</title><link>https://gosang.github.io/posts/design-principles/dry/</link><pubDate>Thu, 11 Aug 2022 13:26:13 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/dry/</guid><description>In the realm of software development, the Don&amp;rsquo;t-Repeat-Yourself (DRY) design principle stands as a cornerstone, emphasizing the importance of avoiding redundancy in code. This principle is more than just a catchy phrase; it&amp;rsquo;s a philosophy that guides developers toward writing efficient, maintainable, and scalable code. In this blog, we&amp;rsquo;ll delve into the essence of DRY, its rationale, its application in microservices and modular monolithic architectures, and its practical implementation in an e-commerce system using C# dot net core examples.</description></item><item><title>Implementing Event Bus With RabbitMQ in .NET Core</title><link>https://gosang.github.io/posts/design-principles/messaging/implementing-event-bus-with-rabbitmq-in-dotnet-core/</link><pubDate>Sat, 30 Jul 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/messaging/implementing-event-bus-with-rabbitmq-in-dotnet-core/</guid><description>As a Software Engineer, you understand the importance of efficient communication between components in a distributed system. In this blog post, we&amp;rsquo;ll explore the implementation of an event bus with RabbitMQ in .NET Core, focusing on an e-commerce system built using .NET Core services and APIs. We&amp;rsquo;ll leverage MediatR for CQRS, AutoMapper for object mapping, EF Core InMemory database for simplicity, and xUnit for unit tests. Let&amp;rsquo;s dive into the rationale, implementation steps, advantages, and best practices.</description></item><item><title>Implementing Redis as a Cache Service in .NET Core</title><link>https://gosang.github.io/posts/design-patterns/caching/implementing-redis-cache-in-dotnet-core/</link><pubDate>Sun, 17 Jul 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/caching/implementing-redis-cache-in-dotnet-core/</guid><description>Caching is a critical component in modern software development, playing a crucial role in optimizing performance, reducing latency, and enhancing overall user experience. In the context of microservices or modular monolithic applications, implementing Redis as a Cache Service is a powerful strategy. In this blog post, we will explore what Redis is, the rationale behind using it as a Cache Service, its implementation in an e-commerce system using .NET Core, and best practices.</description></item><item><title>Using RabbitMQ with ASP.NET Core</title><link>https://gosang.github.io/posts/design-principles/messaging/rabbitmq-with-dotnet-core/</link><pubDate>Wed, 29 Jun 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/messaging/rabbitmq-with-dotnet-core/</guid><description>In the ever-evolving landscape of modern software development, efficient communication between components is crucial. As applications grow in complexity and adopt microservices architecture, a reliable message broker is essential. RabbitMQ, a powerful open-source message broker, has become a cornerstone technology for achieving scalable and robust communication between different parts of an application. In this blog, we will dive deep into RabbitMQ, explain its rationale, explore how it resolves common problems, and demonstrate its usage with ASP.</description></item><item><title>Implementing In-Memory Caching in .NET Core with IMemoryCache</title><link>https://gosang.github.io/posts/design-patterns/caching/implementing-imemorycache-in-dotnet-core/</link><pubDate>Tue, 14 Jun 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/caching/implementing-imemorycache-in-dotnet-core/</guid><description>Caching is a fundamental technique in software development to improve application performance and responsiveness. In the context of .NET Core, one powerful tool for implementing caching is the IMemoryCache interface. In this blog post, we will explore what In-Memory Caching is, the rationale behind using it with IMemoryCache, its implementation in an e-commerce system using .NET Core, and compare its advantages with Redis Caching.
What is In-Memory Caching with IMemoryCache? In-Memory Caching is a technique where frequently accessed data is stored in memory, reducing the need to fetch it from the data source repeatedly.</description></item><item><title>gRPC: Revolutionizing Communication in Modern Microservices with .NET Core</title><link>https://gosang.github.io/posts/design-principles/microservices/grpc/</link><pubDate>Sat, 28 May 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/microservices/grpc/</guid><description>Introduction In the dynamic landscape of microservices architecture, efficient communication between services is paramount. Enter gRPC, which stands for gRPC Remote Procedure Call. It&amp;rsquo;s a high-performance, open-source RPC (Remote Procedure Call) framework developed by Google. In this blog post, we&amp;rsquo;ll delve into the intricacies of gRPC, explore its application in the context of a .NET 6 e-commerce system, and discuss best practices and use cases.
Understanding gRPC What is gRPC? gRPC is a framework that facilitates communication between distributed systems by enabling clients to make calls to methods on a server application as if it were a local object.</description></item><item><title>Difference Between Imemorycache and Redis</title><link>https://gosang.github.io/posts/design-patterns/caching/difference-between-imemorycache-and-redis/</link><pubDate>Mon, 16 May 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/caching/difference-between-imemorycache-and-redis/</guid><description>Caching is a pivotal technique in optimizing application performance, and in the world of .NET Core, developers have two powerful tools at their disposal: .NET Core IMemoryCache and Redis Caching. Each solution has distinct characteristics and is tailored for specific use cases.
.NET Core IMemoryCache Overview In .NET Core, the IMemoryCache interface is a built-in caching mechanism that provides an in-memory store for frequently accessed data. It is part of the Microsoft.</description></item><item><title>Understanding Idempotency in Microservices with .NET Core</title><link>https://gosang.github.io/posts/design-principles/microservices/idempotency/</link><pubDate>Mon, 25 Apr 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/microservices/idempotency/</guid><description>Introduction In distributed systems and microservices architecture, ensuring the reliability and consistency of operations becomes a critical challenge. One key concept that plays a pivotal role in addressing this challenge is Idempotency. In this blog post, we&amp;rsquo;ll delve into the meaning of Idempotency, explore its rationale, understand its applications in the context of microservices (using .NET Core), and discuss the advantages, disadvantages, and best practices associated with it.
What is Idempotency?</description></item><item><title>Caching Pattern</title><link>https://gosang.github.io/posts/design-patterns/caching/caching-pattern/</link><pubDate>Tue, 12 Apr 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/caching/caching-pattern/</guid><description>Caching is a crucial aspect of modern software development, especially in the context of microservices or modular monolithic applications. It helps improve performance, reduce latency, and enhance the overall user experience. In this blog post, we will delve into five caching patterns: Cache Aside, Write Through, Read Through, Write Back, and Write Around, exploring their characteristics, use cases, and code snippets using .NET.
1. Cache Aside Overview Cache Aside, also known as Lazy Loading, is a popular caching pattern where the application code is responsible for managing the cache.</description></item><item><title>Apache Kafka With .NET Core</title><link>https://gosang.github.io/posts/design-principles/messaging/apache-kafka-with-dotnet-core/</link><pubDate>Sat, 09 Apr 2022 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-principles/messaging/apache-kafka-with-dotnet-core/</guid><description>Introduction Apache Kafka has emerged as a game-changer in the realm of distributed systems, offering a robust and scalable solution for building event-driven architectures. In this technical blog, we will delve into the intricacies of Apache Kafka, exploring its core concepts, implementation in a .NET Core e-commerce system, and discussing the advantages, disadvantages, issues, and best practices associated with its use.
Understanding Apache Kafka What is Apache Kafka? Apache Kafka is a distributed streaming platform that excels at handling real-time data feeds and creating scalable, fault-tolerant, and high-throughput messaging systems.</description></item><item><title>Chain of Responsibility Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/chain-of-responsibility-pattern/</link><pubDate>Tue, 01 Mar 2022 12:22:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/chain-of-responsibility-pattern/</guid><description>The Chain of Responsibility Pattern is a behavioral design pattern that allows you to pass requests along a chain of handlers. Each handler can choose to process the request or pass it to the next handler in the chain. This pattern promotes loose coupling between the sender and receiver of a request, making it a powerful tool in building extensible and maintainable software systems. In this blog, we will explore what the Chain of Responsibility Pattern is, its rationale, how it can be used in C# .</description></item><item><title>Repository Unit of Work</title><link>https://gosang.github.io/posts/design-patterns/repository-unit-of-work/</link><pubDate>Sat, 12 Feb 2022 08:56:22 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/repository-unit-of-work/</guid><description>In the ever-evolving landscape of software architecture and data management, certain design patterns stand out as foundational concepts that can greatly improve the organization and maintainability of your applications. Among these, the Repository Pattern and the Unit of Work Pattern are two of the most vital. In this comprehensive guide, we&amp;rsquo;ll explore these patterns in depth, understand their significance, and learn how to wield them effectively in a C# .NET Core Web API, harnessing the capabilities of Entity Framework Core 6.</description></item><item><title>Repository Pattern</title><link>https://gosang.github.io/posts/design-patterns/repository-pattern/</link><pubDate>Sat, 29 Jan 2022 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/repository-pattern/</guid><description>In the realm of software development, maintaining a clean, organized, and efficient codebase is paramount. One of the key design patterns that facilitates this is the Repository Pattern. In this comprehensive guide, we&amp;rsquo;ll embark on a journey to understand the Repository Pattern from the ground up, exploring its purpose, the problems it elegantly resolves, and how to employ it in a C# .NET Core Web API powered by Entity Framework Core 6.</description></item><item><title>Factory Pattern</title><link>https://gosang.github.io/posts/design-patterns/creational/factory-pattern/</link><pubDate>Sun, 05 Dec 2021 13:19:18 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/creational/factory-pattern/</guid><description>Design patterns play a crucial role in creating modular, scalable, and maintainable software. Among them, Factory Patterns are widely used to encapsulate object creation, providing a flexible way to instantiate objects without specifying their exact classes. In this blog, we&amp;rsquo;ll explore three types of Factory Patterns: Concrete, Static, and Abstract, discussing their rationale, usage in an e-commerce system with C# .NET Core examples, advantages, disadvantages, and best practices.
Factory Patterns Overview What is a Factory Pattern?</description></item><item><title>Strategy Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/strategy-pattern/</link><pubDate>Thu, 25 Nov 2021 11:26:09 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/strategy-pattern/</guid><description>When designing software systems, it&amp;rsquo;s essential to create flexible and maintainable code. One way to achieve this is by using design patterns, which are well-established solutions to common software design problems. The Strategy Pattern is one such pattern that offers a structured approach to defining a family of algorithms and making them interchangeable.
In this blog post, we&amp;rsquo;ll explore the Strategy Pattern in detail, its rationale, how it solves problems, and its application in various contexts, including microservices and modular monolithic architectures, using C# .</description></item><item><title>Saga Patterns</title><link>https://gosang.github.io/posts/design-patterns/microservices/saga-patterns/</link><pubDate>Sat, 30 Oct 2021 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/saga-patterns/</guid><description>Microservices architecture has revolutionized the way we design and deploy applications, but it introduces challenges in managing transactions across distributed services. Saga Patterns emerge as a powerful solution to address these challenges and ensure data consistency in a microservices environment. In this blog post, we will explore the Saga Pattern, its variants (Choreographer and Orchestrator Patterns), anti-patterns, and provide practical insights using .NET Core for an e-commerce system.
What is Saga Pattern?</description></item><item><title>Observer Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/observer-pattern/</link><pubDate>Wed, 13 Oct 2021 12:40:53 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/observer-pattern/</guid><description>In software development, designing systems that are flexible, scalable, and maintainable is paramount. One of the key challenges is establishing a communication mechanism between components without tight coupling. The Observer pattern provides an elegant solution to this problem. In this blog, we&amp;rsquo;ll delve into the intricacies of the Observer pattern, explore its applications in an e-commerce system using C# .NET Core, and discuss best practices.
Understanding the Observer Pattern The Observer pattern is a behavioral design pattern where an object, known as the subject, maintains a list of its dependents, called observers, that are notified of state changes.</description></item><item><title>React Hooks in 10 Minutes</title><link>https://gosang.github.io/posts/react/react-hooks-in-10-minutes/</link><pubDate>Mon, 27 Sep 2021 18:01:02 +0000</pubDate><guid>https://gosang.github.io/posts/react/react-hooks-in-10-minutes/</guid><description>React Hooks have revolutionized the way we work with state and side effects in React applications. Introduced in React 16.8, Hooks allow you to use state and other React features without writing a class. In this blog, we&amp;rsquo;ll explore the most commonly used React Hooks - useState, useEffect, useContext, useReducer, useCallback, useMemo, and useRef. We&amp;rsquo;ll dive deep into what each hook is, its rationale, how to use it, and the advantages and disadvantages it offers.</description></item><item><title>Publish–subscribe Pattern</title><link>https://gosang.github.io/posts/design-patterns/microservices/publishsubscribe-pattern/</link><pubDate>Thu, 09 Sep 2021 19:18:44 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/microservices/publishsubscribe-pattern/</guid><description>The Publish–Subscribe pattern, a stalwart in the realm of messaging patterns, orchestrates communication between components in a decoupled manner. Here, publishers categorize messages into topics and broadcast them without knowing the identity of subscribers. Subscribers express interest in specific topics, receiving messages related to those topics. Let&amp;rsquo;s delve into the intricacies of this pattern, exploring its rationale, problem-solving capabilities, and its implementation in the context of a .NET Core e-commerce system.</description></item><item><title>Facade Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/facade-pattern/</link><pubDate>Fri, 20 Aug 2021 12:55:19 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/facade-pattern/</guid><description>In the world of software development, dealing with complex systems is a common challenge. As systems grow in size and functionality, managing and using their various components can become overwhelming. This is where the Facade Pattern comes to the rescue. In this blog post, we will explore what the Facade Pattern is, its rationale, how it can be used, and its relevance in the context of microservices and modular monolithic applications.</description></item><item><title>Vertical Slice Architecture</title><link>https://gosang.github.io/posts/design-architectures/vertical-slice-architecture/</link><pubDate>Sat, 07 Aug 2021 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/vertical-slice-architecture/</guid><description>In the fast-paced world of software development, architects and developers are always on the lookout for innovative approaches to structure code efficiently. One such approach gaining traction is the Vertical Slice Architecture. In this blog post, we&amp;rsquo;ll embark on a journey to understand what Vertical Slice Architecture is, its rationale, and how it resolves common development challenges. We&amp;rsquo;ll explore its implementation in a .NET 6 e-commerce system using MediatR, AutoMapper, EF Core, and xUnit, highlighting its advantages, disadvantages, use cases, and best practices.</description></item><item><title>Adapter Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/adapter-pattern/</link><pubDate>Thu, 22 Jul 2021 08:37:58 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/adapter-pattern/</guid><description>In the world of software development, you often encounter scenarios where you need to integrate new components or systems with existing ones. These components may not always speak the same &amp;ldquo;language,&amp;rdquo; and bridging this gap can be a challenging task. That&amp;rsquo;s where the Adapter Pattern comes to the rescue. In this blog, we will dive deep into the Adapter Pattern, understand its purpose, see how it resolves integration problems, and explore its usage in the context of microservices and modular monolithic applications using C# .</description></item><item><title>Proxy Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/proxy-pattern/</link><pubDate>Tue, 15 Jun 2021 12:26:08 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/proxy-pattern/</guid><description>When building complex software systems, especially in the context of microservices or modular monolithic applications, managing resources efficiently and controlling access to them becomes crucial. The Proxy Pattern is a powerful design pattern that helps solve these challenges by providing a surrogate or placeholder for another object to control its access. In this blog, we will dive deep into the Proxy Pattern, explore its rationale, use cases, advantages, disadvantages, and best practices.</description></item><item><title>Exploring GraphQL With .NET Core</title><link>https://gosang.github.io/posts/dotnet/exploring-graphql-with-dotnet-core/</link><pubDate>Thu, 27 May 2021 18:01:02 +0000</pubDate><guid>https://gosang.github.io/posts/dotnet/exploring-graphql-with-dotnet-core/</guid><description>Understanding GraphQL GraphQL, developed by Facebook, is a query language for APIs that provides a more efficient, flexible, and powerful alternative to traditional REST APIs. Released in 2015, GraphQL allows clients to request exactly the data they need, addressing common issues associated with REST, such as over-fetching and under-fetching of data.
Why GraphQL? The primary goal of GraphQL is to optimize data retrieval. Traditional REST APIs often force clients to accept fixed responses, leading to over-fetching (receiving more data than necessary) or under-fetching (not receiving enough data, necessitating multiple requests).</description></item><item><title>Modern Devops Branching Strategies: a Guide to Efficient Development Workflows</title><link>https://gosang.github.io/posts/devops/modern-devops-branching-strategies-a-guide-to-efficient-development-workflows/</link><pubDate>Fri, 07 May 2021 20:03:14 +0100</pubDate><guid>https://gosang.github.io/posts/devops/modern-devops-branching-strategies-a-guide-to-efficient-development-workflows/</guid><description>In today&amp;rsquo;s fast-paced software development world, DevOps has emerged as a vital approach for fostering collaboration between development and operations teams. A key component of DevOps is the use of branching strategies, which help teams manage code effectively, streamline workflows, and boost development efficiency.
In this blog, we&amp;rsquo;ll explore modern DevOps branching strategies, starting with the importance and rationale behind these strategies. We&amp;rsquo;ll then discuss key considerations for selecting a branching strategy and delve into the most common approaches, including GitFlow, GitHub Flow, GitLab Flow, and Trunk-Based Development (TBD), along with their specific use cases, pros, cons, and their integration with CI/CD pipelines.</description></item><item><title>Event-Driven Architecture</title><link>https://gosang.github.io/posts/design-architectures/event-driven-architecture/</link><pubDate>Sun, 25 Apr 2021 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/event-driven-architecture/</guid><description>Event-Driven Architecture (EDA) has become a pivotal design paradigm in building scalable, loosely-coupled systems. In this blog, we&amp;rsquo;ll delve into the core concepts of Event-Driven Architecture, its implementation in the context of an e-commerce system using C# .NET Core, and explore its advantages, disadvantages, issues, and best practices.
What is Event-Driven Architecture? At its core, Event-Driven Architecture is a design pattern that orchestrates the flow of information between different components or services through events.</description></item><item><title>Composite Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/composite-pattern/</link><pubDate>Fri, 16 Apr 2021 12:56:42 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/composite-pattern/</guid><description>The Composite Pattern is a structural design pattern that allows you to compose objects into tree structures to represent part-whole hierarchies. This pattern lets clients treat individual objects and compositions of objects uniformly. In simpler terms, it enables you to work with both individual objects and groups of objects in a unified manner.
Rationale behind the Composite Pattern The primary goal of the Composite Pattern is to treat individual objects and compositions of objects uniformly.</description></item><item><title>Visitor Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/visitor-pattern/</link><pubDate>Sat, 13 Mar 2021 12:23:36 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/visitor-pattern/</guid><description>The Visitor Pattern is a design pattern that provides a way to separate the algorithm from the object structure it operates on. It is a powerful and flexible pattern that is often used to add new operations to a set of classes without modifying their source code. In this blog, we will dive deep into the Visitor Pattern, explore its rationale, benefits, and drawbacks, and provide real-world examples in the context of a .</description></item><item><title>Interpreter Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/interpreter-pattern/</link><pubDate>Tue, 23 Feb 2021 13:00:16 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/interpreter-pattern/</guid><description>In the realm of design patterns, the Interpreter pattern stands out as a powerful tool for solving specific types of problems. This blog post will delve into the intricacies of the Interpreter pattern, exploring what it is, its rationale, applications in the context of microservices or modular monolithic architectures, and providing practical examples using C# .NET Core.
What is the Interpreter Pattern? The Interpreter pattern falls under the behavioral design patterns category.</description></item><item><title>Null Object Pattern</title><link>https://gosang.github.io/posts/design-patterns/null-object-pattern/</link><pubDate>Sat, 23 Jan 2021 08:43:48 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/null-object-pattern/</guid><description>In the world of software development, handling null values can be a persistent challenge. The Null Object pattern is a design pattern that addresses this challenge by providing a systematic way to represent and handle null objects. This blog post aims to explore the Null Object pattern in-depth, covering its definition, rationale, usage, implementation in C# .NET Core with CacheStorage, advantages, disadvantages, use cases, and best practices.
Understanding the Null Object Pattern What is the Null Object Pattern?</description></item><item><title>Flyweight Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/flyweight-pattern/</link><pubDate>Thu, 05 Nov 2020 12:28:06 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/flyweight-pattern/</guid><description>The Flyweight design pattern is a structural pattern that falls under the category of design patterns in software engineering. It is used to optimize memory usage or computational resources by sharing as much as possible with related objects. The Flyweight pattern is particularly valuable when you need to create a large number of similar objects and you want to conserve resources.
In this blog, we will delve into the Flyweight design pattern, its rationale, how it resolves common problems, and how to implement it using C# .</description></item><item><title>State Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/state-pattern/</link><pubDate>Thu, 08 Oct 2020 12:28:51 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/state-pattern/</guid><description>State Pattern
Introduction In the ever-evolving landscape of software design, patterns play a crucial role in enhancing maintainability, scalability, and flexibility of code. One such design pattern that proves invaluable in managing state-dependent behavior is the State Pattern. In this blog post, we&amp;rsquo;ll delve into the State Pattern, exploring its rationale, application in real-world scenarios, and its advantages and disadvantages.
What is the State Pattern? The State Pattern is a behavioral design pattern that allows an object to alter its behavior when its internal state changes.</description></item><item><title>Prototype Pattern</title><link>https://gosang.github.io/posts/design-patterns/creational/prototype-pattern/</link><pubDate>Fri, 04 Sep 2020 13:09:32 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/creational/prototype-pattern/</guid><description>The Prototype pattern is a creational design pattern that focuses on creating objects by copying an existing object, known as the prototype. This pattern allows you to create new objects by duplicating an existing one, providing a convenient way to produce new instances without specifying their exact types. In this blog post, we&amp;rsquo;ll explore the Prototype pattern, its rationale, implementation in C# .NET Core, and its relevance in the context of microservices and modular monolithic architectures.</description></item><item><title>Decorator Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/decorator-pattern/</link><pubDate>Fri, 28 Aug 2020 12:27:13 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/decorator-pattern/</guid><description>In software development, design patterns play a pivotal role in structuring and organizing code to make it more maintainable and extensible. One such design pattern that proves to be invaluable in enhancing the functionality of objects without altering their structure is the Decorator Pattern. In this blog, we will delve into the Decorator Pattern, its rationale, implementation in C# .NET Core, and how it can be beneficial for microservices and modular monolithic applications.</description></item><item><title>Bridge Pattern</title><link>https://gosang.github.io/posts/design-patterns/structural/bridge-pattern/</link><pubDate>Fri, 17 Jul 2020 13:13:29 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/structural/bridge-pattern/</guid><description>In the realm of software design patterns, the Bridge pattern stands out as a powerful tool for enhancing flexibility and maintainability. This pattern belongs to the structural design patterns, emphasizing the decoupling of abstraction from implementation. In this blog post, we&amp;rsquo;ll delve into the intricacies of the Bridge pattern, its rationale, usage in microservices, and practical implementations in a C# .NET Core e-commerce system.
Bridge Pattern Overview The Bridge pattern is a structural pattern that separates abstraction from its implementation so that both can evolve independently without affecting each other.</description></item><item><title>Microservices Design Architecture</title><link>https://gosang.github.io/posts/design-architectures/microservices/</link><pubDate>Tue, 30 Jun 2020 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/microservices/</guid><description>In the ever-evolving landscape of software development, Microservices Design Architecture has emerged as a game-changer. This architectural paradigm brings flexibility, scalability, and maintainability to the forefront. In this blog, we&amp;rsquo;ll take a deep dive into what microservices are, their key concepts, design architecture, and when to leverage this approach for building robust systems.
What are Microservices? Microservices is an architectural style where a software application is composed of small, independent services that communicate with each other through well-defined APIs.</description></item><item><title>Singleton Pattern</title><link>https://gosang.github.io/posts/design-patterns/creational/singleton-pattern/</link><pubDate>Tue, 16 Jun 2020 12:23:54 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/creational/singleton-pattern/</guid><description>Introduction Design patterns play a crucial role in software development, providing proven solutions to recurring problems. One such pattern is the Singleton pattern, a creational design pattern that ensures a class has only one instance and provides a global point of access to it.
What is the Singleton Pattern? The Singleton pattern restricts the instantiation of a class to a single instance and provides a global point of access to that instance.</description></item><item><title>Template Method Pattern</title><link>https://gosang.github.io/posts/design-patterns/behavioral/template-method-pattern/</link><pubDate>Sat, 23 May 2020 12:24:18 +0000</pubDate><guid>https://gosang.github.io/posts/design-patterns/behavioral/template-method-pattern/</guid><description>The Template Method Pattern is a fundamental design pattern in software development that provides a framework for defining the structure of an algorithm while allowing specific steps of the algorithm to be implemented by derived classes. In this blog, we will explore the Template Method Pattern in detail, including its rationale, how it&amp;rsquo;s used in C# .NET Core, and its relevance in both microservices and modular monolithic applications. We&amp;rsquo;ll also delve into its advantages and disadvantages, use cases, best practices, and recommendations.</description></item><item><title>Modular Monolith Architecture</title><link>https://gosang.github.io/posts/design-architectures/modular-monolith-architecture/</link><pubDate>Sun, 03 May 2020 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/modular-monolith-architecture/</guid><description>In the ever-evolving landscape of software development, choosing the right architecture is crucial for building scalable, maintainable, and efficient applications. One architecture gaining popularity is the Modular Monolith Architecture. In this blog, we&amp;rsquo;ll explore what this architecture entails, its key components, advantages, disadvantages, use cases, and best practices.
What is Modular Monolith Architecture? Modular Monolith Architecture is an approach that combines the modularity of microservices with the simplicity of a monolith architecture.</description></item><item><title>Crafting Your CV With LaTeX and Visual Studio Code</title><link>https://gosang.github.io/posts/latex/crafting-cv-with-latex-in-visual-studio-code/</link><pubDate>Fri, 10 Apr 2020 17:09:37 +0100</pubDate><guid>https://gosang.github.io/posts/latex/crafting-cv-with-latex-in-visual-studio-code/</guid><description>In the professional world, your Curriculum Vitae (CV) is your introduction to potential employers and an essential tool for showcasing your skills, qualifications, and experiences. Creating an impressive and well-formatted CV is crucial. LaTeX, a powerful typesetting system, offers a superior approach to crafting CVs that stand out. Visual Studio Code (VS Code), a versatile code editor, can simplify this process. In this section, we&amp;rsquo;ll explore the context of using LaTeX and VS Code for building your CV, and we&amp;rsquo;ll provide a code snippet to get you started.</description></item><item><title>Simplifying Academic Writing Mendeley and Visual Studio Code With LaTeX</title><link>https://gosang.github.io/posts/latex/simplifying-academic-writing-mendeley-and-vs-code-with-latex/</link><pubDate>Sun, 15 Mar 2020 11:47:55 +0100</pubDate><guid>https://gosang.github.io/posts/latex/simplifying-academic-writing-mendeley-and-vs-code-with-latex/</guid><description>In the realm of academia, the process of writing research papers, academic articles, or journal submissions can be a daunting and complex task. Scholars and researchers face the arduous challenge of managing references, citations, and the actual content creation, while adhering to strict formatting guidelines. In this blog, we will explore how to streamline the process using Mendeley Desktop for reference and citation management and Visual Studio Code with LaTeX as the editor of choice.</description></item><item><title>Clean Architecture</title><link>https://gosang.github.io/posts/design-architectures/clean-architecture/</link><pubDate>Mon, 02 Mar 2020 13:58:28 +0000</pubDate><guid>https://gosang.github.io/posts/design-architectures/clean-architecture/</guid><description>In the ever-evolving world of software development, architects and developers are in pursuit of a design pattern that not only ensures the maintainability of their applications but also enables scalability and adaptability. Clean Architecture, a concept popularized by Uncle Bob (Robert C. Martin), has gained prominence for its ability to provide a structured approach to software design. In this blog post, we will explore Clean Architecture comprehensively, covering its key concepts, components, rationale, and real-world implementation in the context of an online shopping system.</description></item><item><title>Learning LaTeX in 5 Minutes</title><link>https://gosang.github.io/posts/latex/learning-latex-in-5-minutes/</link><pubDate>Sun, 23 Feb 2020 16:43:29 +0100</pubDate><guid>https://gosang.github.io/posts/latex/learning-latex-in-5-minutes/</guid><description>LaTeX is a powerful typesetting system commonly used for creating documents with complex formatting, such as research papers, theses, articles, and CVs. In LaTeX, you work with a set of notations and commands to define the structure and formatting of your document. Let&amp;rsquo;s explore some essential LaTeX notations and provide examples to help you get started.
LaTeX Notations 1. Document Class In LaTeX, you start by specifying the type of document you want to create using the \documentclass command.</description></item><item><title>Publish Research Papers or Formal Blogs With Visual Studio Code and LaTeX</title><link>https://gosang.github.io/posts/latex/publish-research-papers-or-formal-blogs-with-visual-studio-code-and-latex/</link><pubDate>Mon, 20 Jan 2020 12:14:44 +0100</pubDate><guid>https://gosang.github.io/posts/latex/publish-research-papers-or-formal-blogs-with-visual-studio-code-and-latex/</guid><description>In the world of academia, research papers and blogs e.g. a more formal blogs that contain mathematical notations, etc., are essential for sharing knowledge and findings with the broader community. LaTeX, a typesetting system, is the go-to choice for crafting beautifully formatted documents, but creating and managing LaTeX documents efficiently can be a challenge. Visual Studio Code, a powerful and extensible code editor, can simplify this process. In this blog, we&amp;rsquo;ll explore why Visual Studio Code is an excellent choice for creating and publishing research papers, academic journal articles, or technical blogs using LaTeX.</description></item><item><title>Creating and Maintaining a Free Blog in Github Pages, Hugo and Markdown</title><link>https://gosang.github.io/posts/create-and-maintain-free-blog-in-github-pages-hugo-and-markdown/</link><pubDate>Fri, 27 Dec 2019 12:25:49 +0100</pubDate><guid>https://gosang.github.io/posts/create-and-maintain-free-blog-in-github-pages-hugo-and-markdown/</guid><description>Context As a software engineer, programmer or developer, sharing your knowledge and experiences with the tech community is a valuable way to give back and establish your expertise. Maintaining a blog is a great way to achieve this, and it can also serve as a reference point for your personal growth and a platform to demonstrate your skills. In this guide, we&amp;rsquo;ll walk you through creating and maintaining a tech blog using GitHub Pages, Hugo, and Markdown.</description></item></channel></rss>